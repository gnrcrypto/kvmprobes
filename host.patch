diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile
index 42b5540dac58..39dc95cfb749 100644
--- a/arch/x86/kernel/Makefile
+++ b/arch/x86/kernel/Makefile
@@ -41,6 +41,7 @@ KCOV_INSTRUMENT               := n

 CFLAGS_irq.o := -I $(srctree)/$(src)/../include/asm/trace

+obj-y                  += kvmctf.o
 obj-y                  += head_$(BITS).o
 obj-y                  += head$(BITS).o
 obj-y                  += ebda.o
diff --git a/arch/x86/kernel/kvmctf.c b/arch/x86/kernel/kvmctf.c
new file mode 100644
index 000000000000..b16b60041587
--- /dev/null
+++ b/arch/x86/kernel/kvmctf.c
@@ -0,0 +1,196 @@
+#include <linux/kvmctf.h>
+#include <linux/export.h>
+#include <linux/random.h>
+#include <linux/fs.h>
+
+u64 __read_mostly rce_flag = 0;
+EXPORT_SYMBOL(rce_flag);
+u64 __read_mostly read_flag = 0;
+EXPORT_SYMBOL(read_flag);
+u64 write_flag = 0xdeadbeef41424344;
+EXPORT_SYMBOL(write_flag);
+u64 __read_mostly write_flag_value = 0;
+EXPORT_SYMBOL(write_flag_value);
+#ifdef CONFIG_KASAN
+u64 oob_write_flag = 0;
+EXPORT_SYMBOL(oob_write_flag);
+u64 __read_mostly oob_write_flag_value = 0;
+EXPORT_SYMBOL(oob_write_flag_value);
+u64 oob_read_flag = 0;
+EXPORT_SYMBOL(oob_read_flag);
+u64 __read_mostly oob_read_flag_value = 0;
+EXPORT_SYMBOL(oob_read_flag_value);
+u64 dos_flag = 0;
+EXPORT_SYMBOL(dos_flag);
+u64 __read_mostly dos_flag_value = 0;
+EXPORT_SYMBOL(dos_flag_value);
+#endif
+
+u64 kvmctf_check_write_flag(void)
+{
+       if (write_flag != 0xdeadbeef41424344)
+               return write_flag_value;
+       else
+               return 0;
+}
+EXPORT_SYMBOL(kvmctf_check_write_flag);
+
+static void init_rce_flag(void)
+{
+       do {
+               rce_flag = get_random_u64();
+       } while (rce_flag == 0);
+}
+
+static void init_read_flag(void)
+{
+       do {
+               read_flag = get_random_u64();
+       } while (read_flag == 0);
+}
+
+static void init_write_flag_value(void)
+{
+       do {
+               write_flag_value = get_random_u64();
+       } while (write_flag_value == 0);
+}
+
+#ifdef CONFIG_KASAN
+static void init_oob_write_flag_value(void)
+{
+       do {
+               oob_write_flag_value = get_random_u64();
+       } while (oob_write_flag_value == 0);
+}
+
+static void init_oob_read_flag_value(void)
+{
+       do {
+               oob_read_flag_value = get_random_u64();
+       } while (oob_read_flag_value == 0);
+}
+
+static void init_dos_flag_value(void)
+{
+       do {
+               dos_flag_value = get_random_u64();
+       } while (dos_flag_value == 0);
+}
+
+u64 kvmctf_check_oob_write_flag(void)
+{
+       if (oob_write_flag)
+               return oob_write_flag_value;
+       else
+               return 0;
+}
+EXPORT_SYMBOL(kvmctf_check_oob_write_flag);
+
+u64 kvmctf_check_oob_read_flag(void)
+{
+       if (oob_read_flag)
+               return oob_read_flag_value;
+       else
+               return 0;
+}
+EXPORT_SYMBOL(kvmctf_check_oob_read_flag);
+
+u64 kvmctf_check_dos_flag(void)
+{
+       if (dos_flag)
+               return dos_flag_value;
+       else
+               return 0;
+}
+EXPORT_SYMBOL(kvmctf_check_dos_flag);
+#else
+static void init_oob_write_flag_value(void) {}
+static void init_oob_read_flag_value(void) {}
+static void init_dos_flag_value(void) {}
+
+u64 kvmctf_check_oob_write_flag(void)
+{
+       return 0;
+}
+EXPORT_SYMBOL(kvmctf_check_oob_write_flag);
+
+u64 kvmctf_check_oob_read_flag(void)
+{
+       return 0;
+}
+EXPORT_SYMBOL(kvmctf_check_oob_read_flag);
+
+u64 kvmctf_check_dos_flag(void)
+{
+       return 0;
+}
+EXPORT_SYMBOL(kvmctf_check_dos_flag);
+#endif
+
+#define        MAX_SIZE        300
+#define        FILE_PATH       "/home/customeradmin/flags"
+#define        RCE_FILE_PATH   "/root/rce_flag"
+#define ADDR_PATH      "/home/customeradmin/addresses"
+#include <asm/io.h>
+
+void kvmctf_setup_flags(void)
+{
+       struct file *f;
+       char buf[MAX_SIZE];
+
+       /* If already initialized, do nothing. */
+       if (read_flag)
+               return;
+       /* create log file */
+       f = filp_open(FILE_PATH, O_CREAT | O_WRONLY | O_TRUNC, 0666);
+       if (IS_ERR(f)) {
+               printk(KERN_ERR"[KVMCTF]: Flag file open failed");
+               return;
+       } else {
+               init_rce_flag();
+               init_read_flag();
+               init_write_flag_value();
+               init_oob_write_flag_value();
+               init_oob_read_flag_value();
+               init_dos_flag_value();
+#ifdef CONFIG_KASAN
+               snprintf(buf, MAX_SIZE,
+                       "RCE flag: %llx\nRead flag: %llx\nWrite flag: %llx\nOOB write flag:%llx\nOOB read flag: %llx\nDOS flag: %llx\n",
+                       rce_flag, read_flag, write_flag_value,
+                       oob_write_flag_value, oob_read_flag_value,
+                       dos_flag_value);
+#else
+               snprintf(buf, MAX_SIZE,
+                       "RCE flag: %llx\nRead flag: %llx\nWrite flag: %llx\n",
+                       rce_flag, read_flag, write_flag_value);
+#endif
+               kernel_write(f, buf, strlen(buf), 0);
+               filp_close(f, NULL);
+       }
+       /* create RCE file */
+       f = filp_open(RCE_FILE_PATH, O_CREAT | O_WRONLY | O_TRUNC, 0666);
+       if (IS_ERR(f)) {
+               printk(KERN_ERR"[KVMCTF]: RCE file open failed");
+               return;
+       } else {
+               snprintf(buf, MAX_SIZE, "%llx", rce_flag);
+               kernel_write(f, buf, strlen(buf), 0);
+               filp_close(f, NULL);
+       }
+       /* create flags addresses */
+       f = filp_open(ADDR_PATH, O_CREAT | O_WRONLY | O_TRUNC, 0666);
+       if (IS_ERR(f)) {
+               printk(KERN_ERR"[KVMCTF]: Addresses file open failed");
+               return;
+       } else {
+               snprintf(buf, MAX_SIZE, "Write flag address: %px\t%llx\nRead flag address: %px\t%llx\n",
+                       &write_flag, virt_to_phys(&write_flag),
+                       &read_flag, virt_to_phys(&read_flag));
+               kernel_write(f, buf, strlen(buf), 0);
+               filp_close(f, NULL);
+       }
+       /* erase rce flag from memory */
+       rce_flag = 0;
+}
+EXPORT_SYMBOL(kvmctf_setup_flags);
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 7144e5166813..14fe3fc9b2c9 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -58,6 +58,7 @@
 #include <linux/mem_encrypt.h>
 #include <linux/entry-kvm.h>
 #include <linux/suspend.h>
+#include <linux/kvmctf.h>

 #include <trace/events/kvm.h>

@@ -9769,6 +9770,26 @@ int kvm_emulate_hypercall(struct kvm_vcpu *vcpu)
                kvm_sched_yield(vcpu, a0);
                ret = 0;
                break;
+       case KVM_HC_CHECK_WRITE_FLAG:
+               /* Examine the write flag. If it is non-zero, then we know it
+                * has been written via a vulnerability. */
+               ret = kvmctf_check_write_flag();
+               break;
+       case KVM_HC_CHECK_OOB_WRITE_FLAG:
+               /* Examine the oob_write flag. If it is non-zero, then we know
+                * it has been triggered via a vulnerability. */
+               ret = kvmctf_check_oob_write_flag();
+               break;
+       case KVM_HC_CHECK_OOB_READ_FLAG:
+               /* Examine the oob_read flag. If it is non-zero, then we know it
+                * has been triggered via a vulnerability. */
+               ret = kvmctf_check_oob_read_flag();
+               break;
+       case KVM_HC_CHECK_DOS_FLAG:
+               /* Examine the dos flag. If it is non-zero, then
+                * we know it has been triggered via a vulnerability. */
+               ret = kvmctf_check_dos_flag();
+               break;
        case KVM_HC_MAP_GPA_RANGE: {
                u64 gpa = a0, npages = a1, attrs = a2;

diff --git a/include/linux/kvmctf.h b/include/linux/kvmctf.h
new file mode 100644
index 000000000000..a41b94e9e087
--- /dev/null
+++ b/include/linux/kvmctf.h
@@ -0,0 +1,24 @@
+#ifndef _LINUX_KVMCTF_H
+#define _LINUX_KVMCTF_H
+#include <linux/types.h>
+#include <linux/cache.h>
+
+extern u64 __read_mostly read_flag;
+extern u64 write_flag;
+extern u64 __read_mostly write_flag_value;
+#ifdef CONFIG_KASAN
+extern u64 oob_write_flag;
+extern u64 __read_mostly oob_write_flag_value;
+extern u64 oob_read_flag;
+extern u64 __read_mostly oob_read_flag_value;
+extern u64 dos_flag;
+extern u64 __read_mostly dos_flag_value;
+#endif
+
+u64 kvmctf_check_write_flag(void);
+u64 kvmctf_check_oob_write_flag(void);
+u64 kvmctf_check_oob_read_flag(void);
+u64 kvmctf_check_dos_flag(void);
+
+void kvmctf_setup_flags(void);
+#endif
diff --git a/include/uapi/linux/kvm_para.h b/include/uapi/linux/kvm_para.h
index 960c7e93d1a9..17a1112cf6be 100644
--- a/include/uapi/linux/kvm_para.h
+++ b/include/uapi/linux/kvm_para.h
@@ -30,6 +30,10 @@
 #define KVM_HC_SEND_IPI                10
 #define KVM_HC_SCHED_YIELD             11
 #define KVM_HC_MAP_GPA_RANGE           12
+#define KVM_HC_CHECK_WRITE_FLAG                100
+#define KVM_HC_CHECK_OOB_WRITE_FLAG    101
+#define KVM_HC_CHECK_OOB_READ_FLAG     102
+#define        KVM_HC_CHECK_DOS_FLAG   103

 /*
  * hypercalls use architecture specific
diff --git a/mm/kasan/report.c b/mm/kasan/report.c
index 5d9ae80df495..6d64bd07d4b6 100644
--- a/mm/kasan/report.c
+++ b/mm/kasan/report.c
@@ -27,6 +27,7 @@
 #include <linux/sched/task_stack.h>
 #include <linux/uaccess.h>
 #include <trace/events/error_report.h>
+#include <linux/kvmctf.h>

 #include <asm/sections.h>

@@ -419,9 +420,11 @@ static void complete_report_info(struct kasan_report_info *info)

        switch (info->type) {
        case KASAN_REPORT_INVALID_FREE:
+               oob_write_flag = 1;
                info->bug_type = "invalid-free";
                break;
        case KASAN_REPORT_DOUBLE_FREE:
+               oob_write_flag = 1;
                info->bug_type = "double-free";
                break;
        default:
diff --git a/mm/kasan/report_generic.c b/mm/kasan/report_generic.c
index 043c94b04605..51263936ffce 100644
--- a/mm/kasan/report_generic.c
+++ b/mm/kasan/report_generic.c
@@ -24,6 +24,7 @@
 #include <linux/types.h>
 #include <linux/kasan.h>
 #include <linux/module.h>
+#include <linux/kvmctf.h>

 #include <asm/sections.h>

@@ -43,6 +44,14 @@ void *kasan_find_first_bad_addr(void *addr, size_t size)
        return p;
 }

+static void kvmctf_check_oob(struct kasan_report_info *info)
+{
+       if (info->is_write)
+               oob_write_flag = 1;
+       else
+               oob_read_flag = 1;
+}
+
 static const char *get_shadow_bug_type(struct kasan_report_info *info)
 {
        const char *bug_type = "unknown-crash";
@@ -63,31 +72,38 @@ static const char *get_shadow_bug_type(struct kasan_report_info *info)
                 * In theory it's still possible to see these shadow values
                 * due to a data race in the kernel code.
                 */
+               kvmctf_check_oob(info);
                bug_type = "out-of-bounds";
                break;
        case KASAN_PAGE_REDZONE:
        case KASAN_SLAB_REDZONE:
+               kvmctf_check_oob(info);
                bug_type = "slab-out-of-bounds";
                break;
        case KASAN_GLOBAL_REDZONE:
+               kvmctf_check_oob(info);
                bug_type = "global-out-of-bounds";
                break;
        case KASAN_STACK_LEFT:
        case KASAN_STACK_MID:
        case KASAN_STACK_RIGHT:
        case KASAN_STACK_PARTIAL:
+               kvmctf_check_oob(info);
                bug_type = "stack-out-of-bounds";
                break;
        case KASAN_PAGE_FREE:
        case KASAN_SLAB_FREE:
        case KASAN_SLAB_FREETRACK:
+               kvmctf_check_oob(info);
                bug_type = "use-after-free";
                break;
        case KASAN_ALLOCA_LEFT:
        case KASAN_ALLOCA_RIGHT:
+               kvmctf_check_oob(info);
                bug_type = "alloca-out-of-bounds";
                break;
        case KASAN_VMALLOC_INVALID:
+               kvmctf_check_oob(info);
                bug_type = "vmalloc-out-of-bounds";
                break;
        }
@@ -99,12 +115,18 @@ static const char *get_wild_bug_type(struct kasan_report_info *info)
 {
        const char *bug_type = "unknown-crash";

-       if ((unsigned long)info->access_addr < PAGE_SIZE)
+       if ((unsigned long)info->access_addr < PAGE_SIZE) {
+               dos_flag = 1;
                bug_type = "null-ptr-deref";
-       else if ((unsigned long)info->access_addr < TASK_SIZE)
+       }
+       else if ((unsigned long)info->access_addr < TASK_SIZE) {
+               kvmctf_check_oob(info);
                bug_type = "user-memory-access";
-       else
+       }
+       else {
+               kvmctf_check_oob(info);
                bug_type = "wild-memory-access";
+       }

        return bug_type;
 }
@@ -119,8 +141,10 @@ static const char *get_bug_type(struct kasan_report_info *info)
         * a large size_t and its value will be larger than ULONG_MAX/2,
         * so that this can qualify as out-of-bounds.
         */
-       if (info->access_addr + info->access_size < info->access_addr)
+       if (info->access_addr + info->access_size < info->access_addr) {
+               kvmctf_check_oob(info);
                return "out-of-bounds";
+       }

        if (addr_has_metadata(info->access_addr))
                return get_shadow_bug_type(info);
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index 8123f4d15930..2cd9d4453158 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -52,6 +52,7 @@
 #include <linux/lockdep.h>
 #include <linux/kthread.h>
 #include <linux/suspend.h>
+#include <linux/kvmctf.h>

 #include <asm/processor.h>
 #include <asm/ioctl.h>
@@ -5000,6 +5001,7 @@ static int kvm_dev_ioctl_create_vm(unsigned long type)
        struct kvm *kvm;
        struct file *file;

+       kvmctf_setup_flags();
        fd = get_unused_fd_flags(O_CLOEXEC);
        if (fd < 0)
                return fd;
